<p><big><b>2.  The theory of operation</b></big></p>

<p>Pipelining is a technique to improve the throughput of a digital design
by splitting the data processing into stages and moving the items to be
processed through those stages, starting new items before finishing old
items.  The process works just like an assembly line in a car factory: while
each individual car takes a long time to assemble, the assembly line as a
whole produces a new car every few minutes.</p>

<p><b><font color=blue>Figure 1</font></b> show the application of the
pipelining principle to CPU design, using as an example the classic
five-stage pipeline utilized in early implementations of MIPS architecture
back in 1980s.  The items to be processed are the CPU instructions, and the
stages include: fetching the instruction from the instruction memory;
decoding the instruction; reading the values of the applicable registers
(visible to the software, they are called <i>the architecture
registers</i>); performing arithmetic and data memory operations; and
finally, writing the results back to the architecture register file.</p>

<center>

<p><b><font color=blue>Figure 1. An illustration of the idea of pipelining
from the slides that accompany book <i>Digital Design and Computer
Architecture by David Harris and Sarah Harris, 2012</i> (later referred as
<i>DDCA</i>).</font></b></p>

<p><img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2016/11/classic_mips_pipeline_3.png"></p>

</center>

<p><b><font color=blue>Figure 2</font></b> illustrates how a sequence of
MIPS instructions progresses through the classic MIPS pipeline.</p>

<center>

<p><b><font color=blue>Figure 2. An illustration that shows how a sequence
of MIPS instructions progresses through the classic MIPS pipeline. From
<i>DDCA</i>.</font></b></p>

<p><img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2016/11/classic_mips_pipeline_2.png"></p>

</center>

<p><b><font color=blue>Figure 3</font></b> shows the difference between a
single-cycle, non-pipelined microarchitectural implementation of MIPS
architecture and its classic pipelined implementation. Notice the added
flip-flops, non-architectural registers, invisible for the software
engineer.</p>

<center>

<p><b><font color=blue>Figure 3. The difference between a single-cycle,
non-pipelined microarchitectural implementation of MIPS architecture and its
classic pipelined implementation.</font></b></p>

<p><img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2016/11/classic_mips_pipeline.png"></p>

</center>

<p>A fundamental problem with the straightforward pipelined implementation
is the presence of so-called data hazards. Such hazards occur when an
instruction uses data that are supposed to be generated by one of the
previous instructions, and this data is not yet written into the
architectural register (architectural register is a register visible to
software).</p>

<p>There are several methods used to resolve data pipeline hazards. One
method is to simply add empty (<i>nop</i>) instructions to the software.
Another method is to add so-called stalls to the hardware, which forces an
instruction to wait for the previous instruction to complete before using
its result. Both methods result in slowing down the program execution.
However there is another method, called pipeline forwarding, or, more
specifically, bypassing that involves forwarding the calculated data from an
earlier instruction to the instruction which uses the earlier instruction's
result even before the data gets written into the applicable architectural
register. This method is illustrated in <b><font color=blue>Figure
4</font></b> and the applicable schematic is shown on <b><font
color=blue>Figure 5</font></b>.</p>

<center>

<p><b><font color=blue>Figure 4. A sequence of MIPS instructions progressing
through the classic MIPS pipeline when the forwarding is present. From
<i>DDCA</i>.</font></b></p>

<p><img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2016/11/classic_mips_forwarding.png"></p>

</center>

<center>

<p><b><font color=blue>Figure 5. The additional logic needed for the classic
MIPS pipeline to support pipeline forwarding / bypasses. From
<i>DDCA</i>.</font></b></p>

<p><img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2016/11/classic_mips_forwarding_2.png"></p>

</center>

<p>The pipeline in the <i>MIPS microAptiv UP</i> core, which is used in
MIPSfpga, is similar to, but not the same as, the classic MIPS pipeline. The
difference is due to the fact that the pipeline of MIPSfpga core is somewhat
better balanced to achieve higher clock frequency. As a result, bypass
signals in MIPSfpga are different, as shown on <b><font color=blue>Figure
6</font></b>.</p>

<center>

<p><b><font color=blue>Figure 6. Pipeline bypass signals in <i>MIPS
microAptiv UP</i> core used in MIPSfpga.</font></b></p>

<p><img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2016/10/mips_m14kc_bypass_from_sum_no_title.png"></p>

</center>
