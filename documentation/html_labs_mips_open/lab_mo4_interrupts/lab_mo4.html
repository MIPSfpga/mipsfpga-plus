<html>
<head>

<title>
MIPS Open Developer Day Package. Lab MO4 - Introducing interrupts
</title>

<style>

a, body, th, td
{
    font-family : 'Lucida Sans Unicode', 'Lucida Grande', sans-serif;
    font-size   : 12px;
}

pre
{
    font-family : 'Lucida Console', Monaco, monospace;
    font-size   : 12px;
}

</style>
</head>
<body>

<p><big><big><b>
MIPS Open Developer Day Package. Lab MO4 - Introducing interrupts
</b></big></big></p>
<p><big><b>0. Note.  This documentation is in the process of being
updated</b></big></p>

<p>This documentation is in the process of being updated to match the
latest version of the source code.  The planned updates include:</p>

<ol>

<li><p>Informing the user how to use makefiles instead of short Linux
scripts, Windows batch files and GUI.  To see all available make actions
just run <i>make</i> in any board or program directory example:</p>

<p><i>make</i> in subdirectories of <i>boards</i> directory:</i></p>

<pre>
make help   - show this message
make all    - clean, create the board project and run the synthesis
make clean  - delete synth folder
make create - create the board project
make open   - open the board project
make build  - build the board project
make load   - program the FPGA board
</pre>

<p><i>make</i> in subdirectories of <i>programs</i> directory:</i></p>

<pre>
make help       - show this message
make all        - alternative for: compile program size disasm readmemh srecord
make program    - build program.elf from sources
make compile    - compile all C sources to ASM
make size       - show program size information
make disasm     - disassemble program.elf 
make readmemh   - create verilog memory init file for simulation
make srecord    - create Motorola S-record file to use it with UART loader
make clean      - delete all created files
make load       - load program into the device memory, run it and detach gdb
make debug      - load program into the device memory, wait for gdb commands
make attach     - attach to the device, wait for gdb commands
make uart       - load program into the device memory using UART loader
make modelsim   - simulate program and device using Modelsim
make icarus     - simulate program and device using Icarus Verilog
make gtkwave    - show the result of Icarus Verilog simulation in GTKWave
</pre>
</li>

<li><p>Adding support for <i>make uart UART=N</i> where <i>N</i> is USB-to-UART
device number (<i>/dev/ttyUSB0, 1, 2, ... N</i>).</p></li>

<li><p>Light Sensor in peripheral integration lab is now integrated not as an
addional GPIO (General Purpose I/O) device inside GPIO AHB-Lite slave, but
as a separate AHB-Lite slave.</p></li>

<li><p>Source code for pipeline bypass lab (<i>Lab MO6 - The first glance into
pipelining</i>) does not match the documentation. Please look inside the
code to see what it does.</p></li>

<li><p>The new CorExtend / UDI - User Defined Instructions example does not
have an instruction. Please refer to MIPS Open Day slides to figure out what
it does.</p></li>

</ol>
<p><big><b>1.  Introduction</b></big></p>

<p>This lab shows the basic usage of interrupts in MIPS CPUs.  The lab also
demonstrates how the interrupts can offload the processor from constantly
polling I/O ports.  Such offloading increases the number of cycles available
to the processor to spend on computation and other non-I/O tasks.  The lab
example can be used as a basis for a number of follow-up exercises that
explore MIPS CPU features related to the interrupts.  Another group of
follow-up exercises can link the interrupts to software parallelism and
context switching in operating systems.  A number of recommended follow-up
exercises are listed at the end of this lab.</p>

<p>This lab can be also combined with the previous lab, <i>MIPSfpga. 
Lab MO3 - Integrating a peripheral: the light sensor example</i>, to create
a student project that demonstrates the interrupt-driven approach to
input/output, and compares this approach to polling I/O ports without using
interrupts.</p>
<p><big><b>2.  The theory of operation</b></big></p>

<p>Interrupt is one of the key concepts in computer programming and system
design.  Interrupt is basically a feature of a CPU that forces the processor
to suspend the regular flow of instruction execution and to jump to a
certain program address in response to some external event.  The external
event is usually a change in a hardware signal from outside of the CPU.  The
memory location (or, in some processors, an index in an array of memory
locations) where the processor jumps to, is called the interrupt vector. 
The piece of code where the control goes after landing on the interrupt
vector, is called the interrupt service routine, or ISR.  After the ISR is
executed, the control goes back to the program location that was executed by
the processor when it received the interrupt.</p>

<p>The external event that causes the interrupt can be a tick of a timer
clock.  Such timer interrupts are useful to organize task switching in a
system where several software tasks, or programs, share the same processor,
which switches between them.  Another example of an external event that
causes an interrupt is a signal about the completion of an input/output
operation.  Such I/O interrupts are useful to offload the regular program
flow from constant polling of I/O registers, checking their status, as shown
on <b><font color=blue>Figure 1</font></b>.</p>

<center>

<p><b><font color=blue>Figure 1.  The action of an I/O interrupt.</font></b>
The source of the figure: <a
href="http://virtualirfan.com/history-of-interrupts">http://virtualirfan.com/history-of-interrupts</a>.</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/WhatIsAnInterrupt.png"
/>

</center>

<p>Interrupt, sometimes called more specifically hardware interrupt, is a
special case of a more general term "exception".  An exception is suspending
the regular instruction flow and jumping to a vector in response not only to
an external signal, but also to some internal conditions of the CPU, the
conditions that require immediate attention.  Such conditions include
errors: arithmetic overflows, accessing out of range address, running a
privileged instruction in non-privileged (user) mode, bus errors, and other
unusual conditions.  Some of those errors should terminate the offending
program, while others should cause the program to recover, though the action
of the exception service routine.  Some of those conditions, like memory
address exceptions, may be not considered errors at all, but parts of the
mechanics of virtual memory implementation.  There are also so-called
software interrupts, the exceptions that are intentionally caused by the
program to request the services of the operating system.  Exceptions are
also used in the processor's debug interface.  During this lab we will deal
strictly with "true" hardware interrupts.  To learn about the other aspects
of exceptions, please consult the core and architecture documentation.</p>

<p>Historically, the need for exceptions and interrupts was so obvious that
they appeared very early in the history of computers, as shown on <b><font
color=blue>Figure 2</font></b>.</p>

<center>

<p><b><font color=blue>Figure 2.  The history of exceptions and
interrupts.</font></b> The source of the figure: <a
href="http://virtualirfan.com/history-of-interrupts">http://virtualirfan.com/history-of-interrupts</a>.</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/HistoryOfInterrupts.png"
/>

</center>

<p>According to the article <i>Interrupts</i> by Mark Smotherman (<a
href="https://people.cs.clemson.edu/~mark/interrupts.html#dyseac">https://people.cs.clemson.edu/~mark/interrupts.html#dyseac</a>),
the first computer that employed I/O interrupts was DYSEAC, the second
version of SEAC, the Standards Electronic Automatic Computer.  According to
Wikipedia (<a
href="https://en.wikipedia.org/wiki/DYSEAC">https://en.wikipedia.org/wiki/DYSEAC</a>),
"DYSEAC was a first-generation computer built by the National Bureau of
Standards for the US Army Signal Corps.  It went into operation in April
1954".  According to Smotherman, DYSEAC was perhaps also the first mobile
computer, carried in two tractor trailers at 12 and 8 tons, as shown on
<b><font color=blue>Figure 3</font></b>.</p>

<center>

<p><b><font color=blue>Figure 3.  DYSEAC, the first computer with I/O
interrupts.</font></b> The source of the figure: <a
href="http://ed-thelen.org/comp-hist">http://ed-thelen.org/comp-hist</a>.</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/BRL61-0234.jpg"
/>

</center>

<p><big><b>3. Lab steps</b></big></p>

<p>This section outlines the sequence of steps, necessary to complete the
lab.  Almost all generic steps in this lab are the same as in <i>MIPSfpga
2.0 Lab MO1.  Using MIPSfpga with Serial Loader Flow that does not require
BusBlaster board and OpenOCD software</i>.  Such generic steps are not
described in this section.  Only the steps different from <i>Lab MO1</i> are
explained in details.</p>

<p><big><b>3.1. Briefly review the reference materials</b></big></p>

<p>Look into <i>Appendix A.  A list of recommended materials to review
before and during the interrupt lab</i>.  Briefly review the listed
materials to get understanding where to look for the reference information
during the lab.</p>

<p><big><b>3.2.  Review the information about interrupt-related hardware
signals</b></big></p>

<p>Review <i>MIPS32&reg; microAptiv&trade; UP Integrator's Guide</i>,
<i>Chapter 4: Interrupt Interface</i>.  This manual is included in
<i>MIPSfpga</i> package.  The most important information is the description
of interrupt pin signal <i>SI_Int</i> used in the lab.  In the course of the
lab this multi-bit signal is connected to the buttons on FPGA board.  This
allows triggering different interrupt by pressing the corresonding
buttons.</p>


<p><big><b>3.3. Setup the hardware configuration parameters</b></big></p>

<p>Modify the configuration parameters in the file
<i>system_rtl/mfp_ahb_lite_matrix_config.vh</i> as follows:</p>

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.39.30.png"
/>

<p><big><b>3.4. Review the lab-specific hardware modifications</b></big></p>

<p>Review the following fragment of <i>system_rtl/mfp_system.v</i>:</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.38.43.png"
/>

<p><big><b>3.5.  Connect the board to the computer</b></big></p>

<p>For <i>Digilent</i> boards, such as <i>Nexys4</i>, <i>Nexys4 DDR</i> or
<i>Basys3</i>, this step is obvious.  For <i>Altera/Terasic</i> boards some
additional steps required:</p>

<ol>

<li>Connect USB-to-UART connector to FPGA board.  Either <i>FT232RL</i> or
<i>PL2303TA</i> that you can by from AliExpress or Radio Shack will do the
job.  <i>TX</i> output from the connector (green wire on <i>PL2303TA</i>)
should go to pin 3 from right bottom on Terasic DE0, DE0-CV, DE1, DE2-115
(right top on DE0-Nano) and <i>GND</i> output (black wire on
<i>PL2303TA</i>) should be connected to pin 6 from right bottom on Terasic
DE0, DE0-CV, DE1, DE2-115 (right top on DE0-Nano).  Please consult photo
picture in <i>Lab MO1</i> to avoid short-circuit or other connection
problems.</li>

<li>For <i>FT232RL</i> connector: make sure to set 3.3V/5V jumper on
<i>FT232RL</i> part to 3.3V.</li>

<li>For the boards that require external power in addition to the power that
comes from USB, connect the power supply.  The boards that require the extra
power supply include <i>Terasic DE2-115</i>.</li>

<li>Connect FPGA board to the computer using main connection cable provided
by the board manufacturers.  Make sure to put USB cable to the right jack
when ambiguity exists (such as in <i>Terasic DE2-115</i> board).</li>

<li>Make sure to power the FPGA board (turn on the power switch) before
connecting the UART cable from USB-to-UART connector to the computer. 
Failing to do so may result in electric damage to the board.</li>

<li>Connect USB-to-UART connector to FPGA board.</li>

</ol>

<p><big><b>3.6.  Run the synthesis and configure the FPGA with the
synthesized MIPSfpga system</b></big></p>

<p>This step is identical to the synthesis step in <i>Lab MO1</i></p>

<p><big><b>3.7.  Go to the lab directory and clean it up</b></big></p>

<p>Under Windows:</p>

<blockquote><pre>
cd programs\04_interrupts
00_clean_all.bat
</pre></blockquote>

<p>Under Linux:</p>

<blockquote><pre>
cd programs/04_interrupts
./00_clean_all.sh
</pre></blockquote>

<p><big><b>3.8.  Review the portion of the lab program code that does not
use interrupts</b></big></p>

<p>The <i>main()</i> function is located in file
<i>programs/04_interrupts/main.c</i>.  This function is executed after the
reset and running the boot sequence.  The main function in this lab simply
runs a counter and outputs its value on a multi-digit seven-segment display
on FPGA board.</p>

<p>The output value is constructed from both high and low bits of the
counter.  This allows the student to observe the digits on the display
changing when running the synthesized system with either fast clock (50 MHz)
and ultra-slow clock (0.75 Hz or 12.5 Hz).  For more details about the
switchable clock see <i>MIPSfpga Lab MO2.  Using switchable clock to
observe the CPU cycle-by-cycle</i>.</p>

<p>Depending on the position of a switch 2, the program can either run with
or without interrupts.  In both cases it resets the counter to predefined
values when either button 0 or button 1 is pressed.</p>

<p>Note that on some FPGA boards button 0 is used as system reset.  For such
boards you can either do the whole lab only using button 1 or re-synthesize
the system, connecting reset to a button or a switch other than button
0.</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.18.06.png"
/>

<p><big><b>3.9.  Prepare the first software run</b></big></p>

<p>Following the procedure described in <i>Lab MO1</i>, compile and link the
program, generate Motorola S-Record file and upload this file into the
memory of the synthesized MIPSfpga-based system on the board.</p>

<p>Under Windows:</p>

<ol>

<li>cd programs\04_interrupts</li>

<li>run 02_compile_and_link.bat</li>

<li>run 08_generate_motorola_s_record_file.bat</li>

<li>run 11_check_which_com_port_is_used.bat</li>

<li>edit 12_upload_to_the_board_using_uart.bat based on the result from the
previous step - set the working port in "set a=" assignment.</li>

<li>Make sure the switches 0 and 1 on FPGA board are turned off and switch 2
is turned on.  Switches 0 and 1 control the speed of the clock, while switch
2 determines whether the program uses interrupts (switch 2 is off) or does
not use interrupts (switch 2 is on).  See <i>3.8.  Review the lab program
code</i>.  If the switches 0 and 1 are not off, the loading through UART is
not going to work.</li>

<li>run 12_upload_to_the_board_using_uart.bat</li>

</ol>

<p>Under Linux:</p>

<p>If uploading program to the board first time during the current Linux
session, add the current user to <i>dialout</i> Linux group. Enter the
<i>root</i> password when prompted:</p>

<blockquote><pre>
sudo adduser $USER dialout
su - $USER
</pre></blockquote>

<p>After that:</p>

<ol>

<li>cd programs/04_interrupts</li>

<li>run ./02_compile_and_link.sh</li>

<li>run ./08_generate_motorola_s_record_file.sh</li>

<li>run ./11_check_which_com_port_is_used.sh</li>

<li>edit ./12_upload_to_the_board_using_uart.sh based on the result from the
previous step - set the working port in "set a=" assignment</li>

<li>Make sure the switches 0 and 1 on FPGA board are turned off and switch 2
is turned on.  Switches 0 and 1 control the speed of the clock, while switch
2 determines whether the program uses interrupts (switch 2 is off) or does
not use interrupts (switch 2 is on).  See <i>3.8.  Review the lab program
code</i>.  If the switches 0 and 1 are not off, the loading through UART is
not going to work.</li>

<li>./run 12_upload_to_the_board_using_uart.sh</li>

</ol>

<p><big><b>3.10. The first run</b></big></p>

<ol>

<li>Set the switches 0 and 1 on FPGA board to off position and switch 2 to
on position. Make sure the switches 0 and 1 are off, otherwise the boot
sequence (a sequence of processor instructions before <i>main</i> function)
will take too long, since these switches control the clock frequency.</li>

<li><p>Reset the processor.  The reset buttons for each board are listed
in the table below:</p>

<table border=1 cellpadding=10 cellspacing=0 rules=all>
<tr>
<th>Board</th>
<th>Reset button</th>
</tr>
<tr><td>Digilent Basys3</td><td>Up</td></tr>
<tr><td>Digilent Nexys4</td><td>Dedicated CPU Reset</td></tr>
<tr><td>Digilent Nexys4 DDR</td><td>Dedicated CPU Reset</td></tr>
<tr><td>Terasic DE0</td><td>Button/Key 0</td></tr>
<tr><td>Terasic DE0-CV</td><td>Dedicated reset button</td></tr>
<tr><td>Terasic DE0-Nano</td><td>Button/Key 0</td></tr>
<tr><td>Terasic DE1</td><td>Button/Key 0</td></tr>
<tr><td>Terasic DE2-115</td><td>Button/Key 0</td></tr>
<tr><td>Terasic DE10-Lite</td><td>Button/Key 0</td></tr>
</table>

</li>

<li>Notice the output on seven-segment display.  Press button 1, observe how
it resets the counter value.</li>

<li>Turn the switch 1 on.  This will switch the system clock from 25 MHz to
12.5 Hz / beats per second.  You should see LED 7 start blinking, it is
connected straight to the system clock.  Notice the speed of counting.</li>

<li>Press button 1, observe how it resets the counter value.</li>

</ol>

<p><big><b>3.12.  Review the material that explains the <i>interrupt</i>
function attribute</b></big></p>

<p>Use the following internet material to make sense of interrupt-specific
function attributes in the code: <i>Using the GNU Compiler Collection (GCC). 
6.31.18 MIPS Function Attributes</i> (<a
href="http://gcc.gnu.org/onlinedocs/gcc/MIPS-Function-Attributes.html">
http://gcc.gnu.org/onlinedocs/gcc/MIPS-Function-Attributes.html</a>).</p>

<p><big><b>3.13.  Review C macros that are used to access Coprocessor 0
registers</b></big></p>

<p>Search for <i>mips/cpu.h</i> header file in Codescape GCC compiler
package.  This file contains a set of macro definitions like
<i>mips32_getcr</i> and <i>mips32_bicsr</i> that aid in accessing
Coprocessor 0 registers.  These registers are needed to setup the
interrupts.</p>

<p><big><b>3.14.  Review <i>Status</i> and <i>Cause</i> Coprocessor 0
register descriptions</b></big></p>

<p>The following materials are useful for the review:</p>

<ul>

<li>Book <i>See MIPS Run, Second Edition, by Dominic Sweetman</i>,
<i>Chapter 3.  Coprocessor 0: MIPS Process Control</i></li>

<li><i>MIPS32&reg; microAptiv&trade; UP Processor Core Family Software
User's Manual</i>, <i>Chapter 6: CP0 Registers of the microAptiv&trade; UP
Core</i></li>

<li><i>MIPS&reg; Architecture For Programmers Volume III: The MIPS32&reg;
and microMIPS32&trade; Privileged Resource Architecture</i></li>

</ul>

<p><big><b>3.15.  Review the portion of the lab program code that uses
interrupts</b></big></p>

<p>The interrupt handler in <i>programs/04_interrupts/main.c</i>:</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.17.21.png"
/>

<p>Setting up the Coprocessor 0 registers for handling the interrupts in
<i>programs/04_interrupts/main.c</i>:</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.18.51.png"
/>

<p>Code to setup the exception vector in
<i>programs/04_interrupts/exceptions.S</i>:</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.27.09.png"
/>

<p>The linker script which includes a new section for the exception vector
in <i>programs/04_interrupts/program.ld</i>:</p>

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-20.31.16.png"
/>

<p><big><b>3.16. Running the program that uses interrupts</b></big></p>

<p>Re-run the step <i>3.10. The first run</i> with switch 2 in "off"
position. Do you notice the difference in program performance? Can you
explain the difference?</p>

<p><big><b>4. Homework: doing everything in assembly</b></big></p>

<p>This section guides the student through the activity of analyzing the
interrupt processing on assembly level.  This activity helps to have a clear
picture on how everything works.</p>

<p><big><b>4.1. Disassemble the ELF file created during the lab</b></big></p>

<p>Under Windows:</p>

<blockquote><pre>
cd programs\04_interrupts
04_disassemble.bat
</pre></blockquote>

<p>Under Linux:</p>

<blockquote><pre>
cd programs/04_interrupts
./04_disassemble.sh
</pre></blockquote>

<p>The generated file is called <i>program.dis</i>.  It is located in the
current directory.</p>

<p><big><b>4.2.  Review and explain the interrupt-related sections of the
code</b></big></p>

<p>Analyze the following sections of
<i>programs/04_interrupts/program.dis</i> file:</p>

<p>The code for the interrupt vector:</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.09.07.png"
/>

<p>The code for the interrupt handler:</p>

<img width=500
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.09.56.png"
/>

<p>The code for setting up the interrupts:</p>

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.17.34.png"
/>

<p>The code that guards incrementing the counter in the main loop against
interrupts.  Such guarding is accomplished using <i>di/ei</i> instruction
pair (disable interrupts / enable interrupts).  Can you explain why is it
necessary?  What wrong could happen if these instructions are missing?  Can
you guess a scenario when such guarding is not going to work?</p>

<img
src="http://www.silicon-russia.com/wp-content/uploads/2017/01/Screenshot-2017-01-15-21.11.05.png"
/>

<p><big><b>4.3.  Rewrite the whole lab in assembly.  Can you hand-write an
interrupts service routine in assembly that has fewer instructions and works
faster than the routine generated by GNU C compiler?</b></big></p>

<p><big><b>5.  Follow-up projects and exercises</b></big></p>

<p>The topic of interrupts is an important one, and we recommend additional
exercises to understand it fully.</p>

<p><big><b>5.1 Lab enhancements</b></big></p>

<p><b>5.1.1 Lab enhancement: Modify the system testbench to study interrupts
using Verilog simulation, without synthesizing the design</b></p>

<p>Create all the necessary scripts to show the main interrupt-related
signals on the waveform.</p>

<p><b>5.1.2 Student exercise: Improve the interrupt lab by exposing program
counter (PC) to the outside seven-segment display</b></p>

<p>Create a variant of the interrupt lab that connects the processor's
program counter (PC) to the outside multiple-digit seven-segment display. 
This connection should be muxed with the regular seven-segment display
output and should be dependent on whether some selected switch or button is
pressed.  With this setup, when the system clock is turned into slow mode,
it will be possible to observe how the processor enters interrupt service
routine.  For more details about the switchable clock see <i>MIPSfpga
Lab MO2.  Using switchable clock to observe the CPU cycle-by-cycle</i>.</p>

<p><b>5.1.3 Student investigation: Which Coprocessor 0 register bits should
be exposed to outside LEDs to observe interrupts in action in slow-clock
mode?</b></p>

<p>Find on the Imagination Technologies website <a
href="http://imgtec.com">http://imgtec.com</a> a manual called <i>MIPS&reg;
Architecture For Programmers Volume III: The MIPS32&reg; and
microMIPS32&trade; Privileged Resource Architecture</i>. Investigate which
Coprocessor 0 register fields are interesting to observe when the processor
core takes an interrupt and enters the interrupt service routine in
slow-clock mode. An example of such field is the <i>EXL</i> (<i>Exception
Level</i>) bit of the Coprocessor 0 <i>Status</i> register.</p>

<p>Modify the core and system RTL to connect these Coprocessor 0 registers
to external LEDs on FPGA board. Some fields, like <i>Status.EXL</i> do not
require changes in core RTL because the original core RTL already outputs
its value to the external pin, <i>SI_EXL</i>. Exposing such fields requires
only changes in the system RTL (<i>system_rtl/mfp_*.v</i> files) . Other
fields may require adding additional ports and connections to the core's RTL
(<i>core_rtl/m14k_*.v</i> files) as well.</p>

<p>Document your changes and create a post on MIPSfpga forum of the
Imagination Technologies website.</p>

<p><big><b>5.2 Synchronizing memory access in interrupts</b></big></p>

<p><b>5.2.1 Exercise: Observe the effect of not disabling the interrupts
around critical section that updates the same variable as the interrupt
handler</b></p>

<p>Comment out the assembly commands that enable and disable interrupts
(<i>asm ("di");</i> and <i>asm ("ei")</i>) around incrementing the counter
variable <i>n</i> in <i>main</i> function inside <i>main.c</i> file:</p>

<blockquote><pre>
   // asm ("di");
   n ++;
   // asm ("ei");
</pre></blockquote>

<p>Build and re-run the program, using both fast and slow clocks. Can you
see the difference in system responsiveness to the interrupts? You may
observe cases when the system takes the interrupt and executes the interrupt
service routine that resets the counter. However after returning from the
interrupt, the counter appears not to be reset. Instead it continues to
increment its old value, set before entering the interrupt service routine.
Can you explain what is going on? We recommend to analyze the assembly
output of <i>gcc</i> compiler by running <i>01_compile_c_to_assembly.sh</i>
under Linux or <i>01_compile_c_to_assembly.bat</i> under Windows.</p>

<p><b>5.2.2 Exercise: Synchronize the updates of a counter variable using
<i>LL/SC</i> (Load-Linked / Store-Conditional) pair of instructions</b></p>

<p>MIPS architecture provides a way of synchronizing variable updates
without disabling interrupts, using a special pair of instructions
<i>LL/SC</i> (Load-Linked / Store-Conditional).  Create a version of
<i>main.c</i> that uses this feature of the processor instead of
<i>DI/EI</i> pair of instructions used in this lab and <i>Exercise
5.2.1</i>.  If you are not familiar with <i>LL/SC</i>, you can review the
following materials:</p>

<ul>

<li><i>MIPS32&reg; microAptiv&trade; UP Processor Core Family Software
User's Manual</i>, section 12.3, the descriptions of <i>LL</i> and <i>SC</i>
instructions. This manual is included in <i>MIPSfpga</i> package</li>

<li>Book <i>See MIPS Run, Second Edition, by Dominic Sweetman</i>, sections
<i>5.8.4 Critical Regions with Interrupts Enabled: Semaphores the MIPS
Way</i> and <i>8.5.2 Load-Linked / Store-Conditional</i>.</li>

</ul>

<p>You can implement this exercise using either a function written in
assembly and called from <i>main</i>, or, alternatively, using <i>asm</i>
construct in C with parameters, as described in online GCC documentation (<a
href="https://gcc.gnu.org/onlinedocs">https://gcc.gnu.org/onlinedocs</a>),
see <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">6.45.2
Extended Asm - Assembler Instructions with C Expression Operands</a></p>

<p><b>5.2.3 Investigation: Why do we need <i>volatile</i> qualifier for the
counter variable?</b></p>

<p>Review the code of <i>main.c</i>. Why do we need counter variable
<i>n</i> to be declared with <i>volatile</i> qualifier? How does the absence
of this qualifier change the result of program execution? Try to run the
program without <i>volatile</i> with different levels of compiler
optimizations. Is there any change in behavior? Review the code produced by
<i>gcc</i> compiler with different <i>-O</i> settings.</p>

<p><big><b>5.3 Timer interrupts</b></big></p>

<p><b>5.3.1 Student project: Timer interrupt lab using <i>Count/Compare</i>
pair of Coprocessor 0 registers present inside <i>MIPS microAptiv UP</i>
core</b></p>

<p>The timer interrupt is a special kind of hardware interrupt that occurs
regularly, with a set frequency, usually in kilohertz range. Such interrupts
are used to measure time intervals and to implement software multitasking,
including parallel task execution in operating systems.</p>

<p>Read both hardware and software documentation about an embedded timer
interrupt used in MIPS cores in conjunction with the <i>Count/Compare</i>
pair of Coprocessor 0 registers. Is this feature present in MIPSfpga? If
yes, implement a lab that uses this feature. This lab may for example
measure time between pressing some button, or do some computation while the
interrupt service routine polls some input.</p>

<p><b>5.3.2 Student project: Timer interrupt lab using a custom timer module
implemented outside <i>MIPS microAptiv UP</i> core</b></p>

<p>Create an alternative implementation of the timer interrupt lab (Exercise
5.3.1), without using the timer interrupt already implemented in <i>MIPS
microAptiv UP</i> core.  In order to create such implementation, write a
custom timer interrupt-generating module in Verilog.  Then connect it to one
of hardware interrupt pins, bits of <i>SI_Int</i> external signal.</p>

<p><b>5.3.3 Student project: Programmable timer interrupt lab using a custom
timer module implemented outside <i>MIPS microAptiv UP</i> core</b></p>

<p>Extend the student project 5.3.2 by interfacing the timer
interrupt-generating module not only to system clock, reset and
<i>SI_Int</i> signal, but also to the system's <i>AHB-Lite</i> bus.  The
goal is that the frequency of interrupts can be controlled by the software
running on MIPSfpga CPU core.  For the details of <i>AHB-Lite</i>
interfacing, see <i>Lab MO3 - Integrating a peripheral: light sensor
example</i>.</p>

<p><b>5.3.4 Student project: A variant of programmable timer interrupt lab
that uses multiple counters and interrupt pins</b></p>

<p>Create a version of the student project 5.3.3 that uses multiple counters
to generate hardware interrupts with different frequences on different
hardware pins (bits of the signal <i>SI_Int</i>).</p>

<p><b>5.3.5 Medium-to-advanced student project: Create a lab demonstrating
the multitasking / context switching</b></p>

<p>An important application of timer interrupts is to facilitate a variant
of parallel programming called task switching, or context switching. 
Context switching is widely used in operating systems, from relatively
simple, like FreeRTOS, to complicated, like Linux.</p>

<p>The idea of context switching is to periodically switch between different
threads of execution, that are also sometimes called processes or tasks. 
The "context" is a reference to a set of information associated with the
task, including program counter (PC) and general-purpose registers (GPR). 
The switch happens inside the timer interrupt service routine that saves the
current context in some memory structure (called in some systems Process
Control Block - PCB), then restores the context of a different process from
another PCB and exits the timer interrupt into the new thread of
execution.</p>

<p>Create a lab that switches between two different C functions, running in
parallel.  You don't need to use any operating system to do this.  Just save
and restore all the necessary registers inside the timer interrupt service
routine, and maintain an illusion of parallel execution of two C programs
for the end-user.  The end-user would observe the outputs from two programs
on LEDs or other output devices.</p>

<p><b>5.3.6 Advanced student project: Port some open-source RTOS, like
FreeRTOS, to MIPSfpga</b></p>

<p>FreeRTOS is a popular real-time operating system, used as an example RTOS
in the course <i>Connected MCU</i> created by Dr.Alexander Dean of North
Carolina State University.  The <i>Connected MCU</i> course demonstrates
FreeRTOS on Microchip PIC32MZ microcontroller that uses a processor core
common with MIPSfpga.  However PIC32MZ uses External Interrupt Controller
which is absent in the default MIPSfpga system which uses Interrupt
Compatibility Mode.  Porting FreeRTOS on MIPSfpga should be an appropriate
project for a graduate student of embedded programming or computer
architecture.</p>

<p><b>5.3.7 Medium-to-advanced student project: Create a lab demonstrating
switching from the user mode to the kernel mode when entering the interrupt
service routine</b></p>

<p>Processor mode is one of the most important concepts in computer science,
particularly in the operating system design.  Different CPUs have somewhat
different modes with different names: user, kernel, privileged, superuser
and others.  MIPS32 architecture supports user mode, kernel mode and
supervisor mode.  According to <i>See MIPS Run, Second Edition, by Dominic
Sweetman</i> the supervisor mode in MIPS is a historical accident, a feature
that was added by a customer request, but was practically never used in a
real system.  So only the user and kernel modes are really used.</p>

<p>In the latest releases of MIPS32 architecture there are some additional
modes: root mode and guest mode.  These modes are related to
hardware-assisted CPU virtualization, which should not to be confused with
the virtual memory feature.  The virtual memory is present even in CPU cores
without hardware-assisted virtualization, including MIPS microAptiv UP core
used in MIPSfpga.  However the hardware-assisted virtualization is not
present in MIPSfpga, so we are not concern about root and guest modes
here.</p>

<p>The processor in kernel mode has complete access to all its architecture
resources, it can execute all instructions, access all memory locations and
all system Coprocessor 0 registers.  This mode is used to run operating
system and device drivers.</p>

<p>The processor in user mode can execute only a subset of instructions, has
no access to system coprocessor registers, and controlled access to memory
locations.  This mode is used to run application programs that may be less
reliable than the operating system.</p>

<p>When an interrupt or, in general, an exception occurs, a processor
switches its mode from user to kernel and jumps to an exception handler, a
piece of code that handles the exception.  When process the exception, the
operating system performs the necessary actions.  Examples of such
actions:</p>

<ul>

<li>If the user code attempted to access a location in memory it should not
access, the operating system can terminate the user code, keeping the memory
of the rest of the system (both OS and other application's memory) in
order.</li>

<li>If the exception is caused by the system timer interrupt, the interrupt
service routine can switch the task/process context and return from the
exception into another user task/process.</li>

<li>If the interrupt came from an input-output device, the interrupt service
routine can perform some action related to access to memory-mapped
input-output registers.  An example of such action is getting a byte
transmitted by SPI protocol and putting it into a buffer that can be later
accessed by the application code.</li>

<li>There are also special user-mode instructions that cause the intentional
exeptions, requesting the system to perform some action in kernel mode.  In
MIPS such instruction is called <i>syscall.</i></li>

<li>Finally, an exception can be caused by an illegal instruction or an
instruction that is not permitted in user mode.  The exception handler can
try to emulate the instruction instead of terminating the user code.</li>

</ul>

<p>Create a lab using MIPSfpga that demonstrates how the processor entering
the user mode.  This lab can expose <i>KSU</i> ("kernel/supervisor/user")
field of Coprocessor 0 <i>Status</i> register by connecting it to the LEDs
on FPGA board and running the system using slow 0.75 Hz or 12.5 Hz clock.</p>

<p>The main challenge in creating this lab is the need to modify the boot
code of the software example.  The current boot code exists the reset into
kernel mode, this should be changed into user mode.  The current boot code
also does not initialize virtual address mapping for the user mode.  See the
documentation on translation lookaside buffer (TLB) and memory-management
unit and modify the boot code to support the new lab.</p>

<p><big><b>5.4 Special kinds of interrupts, interrupt features and
interrupt-like exceptions</b></big></p>

<p><b>5.4.1 Student project and investigation: Non-maskable-interrupt (NMI)
lab</b></p>

<p>Study the information about non-maskable-interrupts (NMI) in
<i>MIPS32&reg; microAptiv&trade; UP Processor Core Family Software User's
Manual</i> and <i>MIPS32&reg; microAptiv&trade; UP Integrator's Guide</i>,
included in <i>MIPSfpga</i> package.</p>

<p>Create a lab that demonstrates NMI interrupts.  Investigate using the
internet the history of NMI in different computers.  Why was this feature
necessary in the past?  How useful is this feature for the modern
applications?</p>

<p><b>5.4.2 Investigation: Evaluate the usefulness and applications of
Vectored Interrupt (VI) mode in MIPS architecture</b></p>

<p>MIPS microAptiv UP core, used in MIPSfpga, supports three interrupt
modes: Interrupt Compatibility mode, Vectored Interrupt (VI) mode, and
External Interrupt Controller (EIC) mode.  So far, the lab and exercises
were using the Interrupt Compatibility mode.  An alternative Vectored
Interrupt (VI) mode adds the ability to prioritize and vector interrupts to
a handler dedicated to that interrupt.  Vectored Interrupt mode also allows
assigning a GPR (General Purpose Register) shadow set for use during
interrupt processing.</p>

<p>Study the documentation and create a lab demonstrating interrupts in
Vectored Interrupt mode.  How many clock cycles does this mode save when an
interrupt is taken?  When does it make sense to use this mode?  Consider
very low-power / low-frequency applications, interrupt response time, usage
of shadow GPR registers (not present in MIPSfpga).</p>

<p>Which interrupt mode is used in Linux?  Can you offer an explanation
why?</p>

<p><b>5.4.3 Investigation: The purpose of <i>IV</i> bit of <i>Cause</i>
Coprocessor 0 register</b></p>

<p>Read about <i>IV</i> bit of <i>Cause</i> Coprocessor 0 register.  Why
would anybody need such interrupt option?  What problem is solved by this
option?  Propose possible answers.</p>

<p><b>5.4.4 Investigation: The purpose of <i>EBase</i> Coprocessor 0
register</b></p>

<p>Read about <i>EBase</i> Coprocessor 0 register and try to explain its
usefulness.  It is only for multiprocessor systems?  How would you use it in
a single-processor system?</p>

<p><b>5.4.5 Advanced student project: Building External Interrupt Controller
(EIC)</b></p>

<p>The External Interrupt Controller (EIC) mode is another interrupt mode,
supported by MIPS microAptiv UP core used in MIPSfpga. EIC mode redefines
the way interrupts are handled to provide full support for an external
interrupt controller that handles prioritization and vectoring of
interrupts. EIC mode is used in MIPS-based microcontrollers from Microchip
Technology, including some microcontrollers from the Microchip PIC32MZ
family that are built around MIPS microAptiv UP core, the same core used in
MIPSfpga.</p>

<p>The functionality of External Interrupt Controller created by Microchip
is described in Microchip software documentation, the courses taught by
Microchip during Microchip Master Conference, as well as in Imagination,
Microchip and Digilent-sponsored course <i>Connected MCU</i> created by Dr.
Alexander Dean of North Carolina State University.</p>

<p>MIPSfpga allows you to create an alternative External Interrupt
Controller, with its own interrupt scheduling and prioritization, and
compare your solution to the solution from Microchip Technology. This is a
significant research project that can be combined with studies on Real-Time
Operating Systems (RTOS).</p>

<p><b>5.4.6 Student project: Create a lab demonstrating imprecise Bus Error
exception</b></p>

<p>All interrupts are exceptions triggered by changes in external signals,
but not all exceptions triggered by changes in external signals are in fact
interrupts.  There is an exception called Bus Error, which is triggered by a
specific AHB-Lite bus response.  This exception is also remarkable because
it is not always precise, i.e.  it may occur with <i>EPC</i> pointing to a
different instruction.</p>

<p>Read about imprecise exceptions and bus errors in documentation and
create a lab that demonstrates this feature.  The useful chapters to read
are:</p>

<ul>

<li><i>MIPS32&reg; microAptiv&trade; UP Integrator's Guide</i>, <i>Table 2.3
Signal Descriptions for m14k_cpu Level</i>, the description of <i>HRESP</i>
signal: <i>"The transfer response.  When LOW, the HRESP signal indicates
that the transfer status is OKAY.  When HIGH, the HRESP signal indicates
that the transfer status is ERROR."</i>.  This manual is included in
<i>MIPSfpga</i> package.</li>

<li><i>MIPS32&reg; microAptiv&trade; UP Processor Core Family Software
User's Manual</i>, section <i>5.8.15 Bus Error Exception - Instruction Fetch
or Data Access</i>.  Notice the statement <i>"Bus errors taken on the
requested (critical) word of an instruction fetch or data load are precise. 
Other bus errors, such as stores or non-critical words of a burst read, can
be imprecise."</i> This manual is included in <i>MIPSfpga</i> package.</li>

<li>Book <i>See MIPS Run, Second Edition, by Dominic Sweetman</i>, section
<i>5.1 Precise Exceptions</i> and <i>Table 3.2 ExcCode Values: Different
Kinds of Exceptions</i>.</li>

</ul>

<p><big><b>5.5 Effect of interrupt on processor
microarchitecture</b></big></p>

<p><b>5.5.1 Advanced student project: Create a lab demonstrating the effect
of interrupts on processor pipelining</b></p>

<p>Create all the necessary scripts to show the main interrupt-related
signals on the waveform during the simulation in Verilog simulator.  Show on
the waveform how an interrupt flushes the processor pipeline.  Which stage
of the pipeline is used to take a pending interrupt?</p>

<p>Connect the pipeline control signals to external LEDs on FPGA board and
demonstrate how an interrupt flushes the processor pipeline from the
instructions which are not going to graduate because of the interrupt.</p>

<p>If you need more information about CPU pipelining in MIPSfpga, you can
review <i>MIPSfpga.  Lab MO6 - The first glance into pipelining</i>.</p>

<p><big><b>5.6 Reimplement the light sensor lab making it
interrupt-driven</b></big></p>

<p>After going through this lab, go back to the light sensor lab <i>MIPSfpga
2.0.  Lab MO3 - Integrating a peripheral: the light sensor example</i>) and
re-implement it using interrupt-driven approach.  Modify the light sensor
interfacing module so it issues an interrupt when the measured value
changes.  Connect the interrupt pin to <i>SI_Int</i> signal of MIPS
microAptive UP core.  Measure the system performance improvement that comes
from offloading input-output to the interrupt service routine.</p>
<p><big><b>Appendix A.  A list of recommended materials to review before and
during the interrupt lab</b></big></p>

<ul>

<li><p>Book <i>See MIPS Run, Second Edition, by Dominic Sweetman</i>. 
<i>Chapter 5.  Exceptions, Interrupts, and Initialization</i>, sections
5.1-5.8.  If you don't have this book, see <i>Appendix B</i> in this lab for
critical excerpts from Sweetman's book.  The specific book sections to
study:</p>

<ul>

<li><p><i>Chapter 5.  Exceptions, Interrupts, and Initialization</i>,
sections 5.1-5.8</p></li>

<li><p><i>Chapter 3.  Coprocessor 0: MIPS Process Control</i>, sections:</p>

<ul>

<li><i>3.3.1 Status Register (SR)</i></li>

<li><i>3.3.2 Cause Register</i></li>

<li><i>3.3.3 Exception Restart Address (EPC) Register</i></li>

<li><i>3.3.5 Count/Compare Registers: The On-CPU Timer</i></li>

<li><i>3.3.8 EBase and IntCtl: Interrupt and Exception Setup</i></li>

<li><i>3.3.9 SRSCtl and SRSMap: Shadow Register Setup</i></li>

<li><i>3.3.10 Load-Linked Address (LLAddr) Register</i></li>

</ul>

</li>

<li><p><i>Chapter 8.  Complete Guide to the MIPS Instruction Set</i>,
section <i>8.5.2 Load-Linked / Store-Conditional</i></p></li>

</ul>
</li>

<li><p><i>MIPS32&reg; microAptiv&trade; UP Integrator's Guide</i>,
<i>Chapter 4: Interrupt Interface</i>.  This manual is included in
<i>MIPSfpga</i> package.</p></li>

<li><p><i>MIPS32&reg; microAptiv&trade; UP Processor Core Family Software
User's Manual</i>, relevant sections from:</p>

<ul>

<li>

<i>Chapter 5: Exceptions and Interrupts in the microAptiv&trade; UP
Core</i></li>

<li><i>Chapter 6: CP0 Registers of the microAptiv&trade; UP Core</i></li>

<li>section 12.3, the descriptions of <i>LL</i> and <i>SC</i>
instructions</li>

</ul>

<p>This manual is included in <i>MIPSfpga</i> package.</p>

</li>

<li><p>Relevant sections from the manual <i>MIPS&reg; Architecture For
Programmers Volume III: The MIPS32&reg; and microMIPS32&trade; Privileged
Resource Architecture</i>.  This manual can be downloaded from Imagination
Technologies website <a
href="http://imgtec.com">http://imgtec.com</a></p></li>

</ul>

<p><big><b>Appendix B.  Excerpts from a book <i>See MIPS Run, Second
Edition, by Dominic Sweetman</i> about the interrupt
processing.</b></big></p>

<blockquote>

<p><big><b>Chapter 5.  Exceptions, Interrupts, and
Initialization</b></big></p>

<p>In the MIPS architecture interrupts, traps, system calls, and everything
else that can disrupt the normal flow of execution are called exceptions and
are handled by a single mechanism.  What sort of events are they?</p>

<ul>

<li><p><i>External events</i>: Some event outside the CPU core—that is, from
some real "wire" input signal.  These are interrupts.  (Note: There are some
more obscure noninterrupt external events like bus errors reported on a
read—for now, just assume that they are a special sort of interrupt). 
Interrupts are used to direct the attention of the CPU to some external
event: an essential feature of an OS that attends to more than one different
event at a time.  Interrupts are the only exception conditions that arise
from something independent of the CPU's normal instruction stream.  Since
you can't avoid interrupts just by being careful, there have to be software
mechanisms to inhibit the effect of interrupts when necessary.</p></li>

<li><p><i>Memory translation exceptions</i>: These happen when an address
needs to be translated, but no valid translation is available to the
hardware or perhaps on a write to a write-protected page.</p>

<p>The OS must decide whether such an exception is an error or not.  If the
exception is a symptom of an application program stepping outside its
permitted address space, it will be fixed by terminating the application to
protect the rest of the system.  The more common benign memory translation
exceptions can be used to initiate operating system functions as complex as
a complete demand-paged virtual memory system or as simple as extending the
space available for a stack.</p></li>

<li><p><i>Other unusual program conditions for the kernel to fix</i>:
Notable among these are conditions resulting from floating-point
instructions, where the hardware is unable to cope with some difficult and
rare combination of operation and operands and is seeking the services of a
software emulator.  This category is fuzzy, since different kernels have
different ideas about what they're willing to fix.  An unaligned load may be
an error on one system and something to be handled in software on
another.</p></li>

<li><p><i>Program or hardware-detected errors</i>: This includes nonexistent
instructions, instructions that are illegal at user-privilege level,
coprocessor instructions executed with the appropriate SR flag disabled,
integer overflow, address alignment errors, and accesses outside
<i>kuseg</i> in user mode.</p></li>

<li><p><i>Data integrity problems</i>: Many MIPS CPUs continually check data
on the bus or data coming from the cache for a per-byte parity or for word-
wide error-correcting code.  Cache or parity errors generate an exception in
CPUs that support data checking.</p></li>

<li><p><i>System calls and traps</i>: These are instructions whose whole
purpose is to generate recognizable exceptions; they are used to build
software facilities in a secure way (system calls, conditional traps planted
by careful code, and breakpoints).</p></li>

</ul>

</blockquote>

<blockquote>

<p><big><b>5.3 Exception Vectors: Where Exception Handling
Starts</b></big></p>

<p>.  .  .  .  .  .  .  .  .  .</p>

<p>Here's what a MIPS CPU does when it decides to take an exception:</p>

<ol>

<li>It sets up <b>EPC</b> to point to the restart location.</li>

<li>It sets <b>SR(EXL)</b>, which forces the CPU into kernel
(high-privilege) mode and disables interrupts.</li>

<li><b>Cause</b> is set up so that software can see the reason for the
exception.  On address exceptions, <b>BadVAddr</b> is also set.  Memory
management system exceptions set up some of the MMU registers too; more
details are given in Chapter 6.</li>

<li>The CPU then starts fetching instructions from the exception entry
point, and everything else is up to software.</li>

</ol>

<p>.  .  .  .  .  .  .  .  .  .</p>

<p><big><b>5.5 Returning from an Exception</b></big></p>

<p>The return of control to the exception victim and the change (if
required) back from kernel to a lower-privilege level must be done at the
same time ("atomically," in the jargon of computer science).  It would be a
security hole if you ran even one instruction of application code at
kernel-privilege level; on the other hand, the attempt to run a kernel
instruction with user privileges would lead to a fatal exception.</p>

<p>MIPS CPUs have an instruction, <b>eret</b>, that does the whole job; it
both clears the <b>SR(EXL)</b> bit and returns control to the address stored
in <b>EPC</b>.</p>

</blockquote>

<blockquote>

<p><big><b>5.8.1 Interrupt Resources in MIPS CPUs</b></big></p>

<p>MIPS CPUs have a set of eight independent (Note: Not so independent if
you're using EIC mode; see section 5.8.5.) interrupt bits in their
<b>Cause</b> register.  On most CPUs you'll find five or six of these are
signals from external logic into the CPU, while two of them are purely
software accessible.  The on-chip counter/timer (made of the <b>Count</b>
and <b>Compare</b> registers, described in section 3.3.5) will be wired to
one of them; it's sometimes possible to share the counter/timer interrupt
with an external device, but rarely a good idea to do so.</p>

<p>An active level on any input signal is sensed in each cycle and will
cause an exception if enabled.</p>

<p>The CPU's willingness to respond to an interrupt is affected by bits in
<b>SR</b>.</p>

<p>There are three relevant fields:</p>

<ul>

<li>The global interrupt enable bit <b>SR(IE)</b> must be set to 1, or no
interrupt will be serviced.</li>

<li>The <b>SR(EXL)</b> (exception level) and <b>SR(ERL)</b> (error level)
bits will inhibit interrupts if set (as one of them will be immediately
after any exception).</li>

<li>The status register also has eight individual interrupt mask bits
<b>SR(IM)</b>, one for each interrupt bit in <b>Cause</b>.  Each
<b>SR(IM)</b> bit should be set to 1 to enable the corresponding interrupt
so that programs can determine exactly which interrupts can happen and which
cannot.</li>

</ul>

<p>To discover which interrupt inputs are currently active, you look inside
the <b>Cause</b> register.  Note that these are exactly that—current
levels—and do not necessarily correspond to the signal pattern that caused
the interrupt exception in the first place.  The active input levels in
<b>Cause(IP)</b> and the masks in <b>SR(IM)</b> are helpfully aligned to the
same bit positions, in case you want to "and" them together.  The software
interrupts are at the lowest positions, and the hardware interrupts are
arranged in increasing order.</p>

<p>In architectural terms, all interrupts are equal.  (Note: That's not
quite true in vectored interrupt and "EIC mode," described in section 5.8.5,
but they're not widely used).  When an interrupt exception is taken, an
older CPU uses the "general" exception entry point—though MIPS 32/64 CPUs
and some other modern CPUs offer an optional distinct exception entry point
reserved for interrupts, which can save a few cycles.  You can select this
with the <b>Cause(IV)</b> register bit.</p>

<p>Interrupt processing proper begins after you have received an exception
and discovered from <b>Cause(ExcCode)</b> that it was a hardware interrupt. 
Consulting <b>Cause(IP)</b>, we can find which interrupt is active and thus
which device is signaling us.  Here is the usual sequence:</p>

<ul>

<li><p>Consult the <b>Cause</b> register IP field and logically "and" it
with the current interrupt masks in <b>SR(IM)</b> to obtain a bit map of
active, enabled interrupt requests.  There may be more than one, any of
which would have caused the interrupt.</p></li>

<li><p>Select one active, enabled interrupt for attention.  Most OSs assign
the different inputs to fixed priorities and deal with the highest priority
first, but it is all decided by the software.</p></li>

<li><p>You need to save the old interrupt mask bits in <b>SR(IM)</b>, but
you probably already saved the whole <b>SR</b> register in the main
exception routine.</p></li>

<li><p>Change <b>SR(IM)</b> to ensure that the current interrupt and all
interrupts your software regards as being of equal or lesser priority are
inhibited.</p></li>

<li><p>If you haven't already done it in the main exception routine, save
the state (user registers, etc.) required for nested exception
processing.</p></li>

<li><p>Now change your CPU state to that appropriate to the higher-level
part of the interrupt handler, where typically some nested interrupts and
exceptions are permitted.</p>

<p>In all cases, set the global interrupt enable bit <b>SR(IE)</b> to allow
higher priority interrupts to be processed.  You'll also need to change the
CPU privilege-level field <b>SR(KSU)</b> to keep the CPU in kernel mode as
you clear exception level and, of course, clear <b>SR(EXL)</b> itself to
leave exception mode and expose the changes made in the status
register.</p></li>

<li><p>Call your interrupt routine.</p></li>

<li><p>On return you'll need to disable interrupts again so you can restore
the preinterrupt values of registers and resume execution of the interrupted
task.  To do that you'll set <b>SR(EXL)</b>.  But in practice you're likely
to do this implicitly when you restore the just-after-exception value of the
whole <b>SR</b> register, before getting into your end-of-exception
sequence.</p></li>

</ul>

<p>When making changes to <b>SR</b>, you need to be careful about changes
whose effect is delayed due to the operation of the pipeline — "CP0
hazards." See section 3.4 for more details and how to program around the
hazards.</p>

</blockquote>

<p><big><b>Appendix C.  Excerpts from the article <i>Using the GNU Compiler
Collection (GCC).  6.31.18 MIPS Function Attributes</i></b></big></p>

<blockquote>

<p><a
href="http://gcc.gnu.org/onlinedocs/gcc/MIPS-Function-Attributes.html">
http://gcc.gnu.org/onlinedocs/gcc/MIPS-Function-Attributes.html</a></p>

<p>These function attributes are supported by the MIPS back end:</p>

<p><font face="Courier">interrupt</font></p>

<blockquote>

<p>Use this attribute to indicate that the specified function is an
interrupt handler.  The compiler generates function entry and exit sequences
suitable for use in an interrupt handler when this attribute is present.  An
optional argument is supported for the interrupt attribute which allows the
interrupt mode to be described.  By default GCC assumes the external
interrupt controller (EIC) mode is in use, this can be explicitly set using
<font face="Courier">eic</font>.  When interrupts are non-masked then the
requested Interrupt Priority Level (IPL) is copied to the current IPL which
has the effect of only enabling higher priority interrupts.  To use vectored
interrupt mode use the argument <font
face="Courier">vector=[sw0|sw1|hw0|hw1|hw2|hw3|hw4|hw5]</font>, this will
change the behavior of the non-masked interrupt support and GCC will arrange
to mask all interrupts from sw0 up to and including the specified interrupt
vector.</p>

<p>You can use the following attributes to modify the behavior of an
interrupt handler:</p>

<p><font face="Courier">use_shadow_register_set</font></p>

<blockquote>

<p>Assume that the handler uses a shadow register set, instead of the main
general-purpose registers.  An optional argument intstack is supported to
indicate that the shadow register set contains a valid stack pointer.</p>

</blockquote>

<p><font face="Courier">keep_interrupts_masked</font></p>

<blockquote>

<p>Keep interrupts masked for the whole function.  Without this attribute,
GCC tries to re-enable interrupts for as much of the function as it can.</p>

</blockquote>

<p><font face="Courier">use_debug_exception_return</font></p>

<blockquote>

<p>Return using the deret instruction.  Interrupt handlers that don't have
this attribute return using eret instead.</p>

</blockquote>

<p>You can use any combination of these attributes, as shown below:</p>

<blockquote>

<font face="Courier"><pre>
          void __attribute__ ((interrupt)) v0 ();

          void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();

          void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();

          void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();

          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked)) v4 ();

          void __attribute__ ((interrupt, use_shadow_register_set,
                               use_debug_exception_return)) v5 ();

          void __attribute__ ((interrupt, keep_interrupts_masked,
                               use_debug_exception_return)) v6 ();

          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked,
                               use_debug_exception_return)) v7 ();

          void __attribute__ ((interrupt("eic"))) v8 ();

          void __attribute__ ((interrupt("vector=hw3"))) v9 ();
</pre></font>

</blockquote>

</blockquote>

</blockquote>
</body>
</html>
